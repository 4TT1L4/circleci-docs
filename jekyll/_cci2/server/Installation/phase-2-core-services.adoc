---
version:
- Server v4.x
- Server Admin
---
= Phase 2 - Core services
:page-layout: classic-docs
:page-liquid:
:page-description: Find the steps and prerequisites for the server v4.x installation.
:icons: font
:toc: macro
:toc-title:

// This doc uses ifdef and ifndef directives to display or hide content specific to Google Cloud Storage (env-gcp) and AWS (env-aws). Currently, this affects only the generated PDFs. To ensure compatability with the Jekyll version, the directives test for logical opposites. For example, if the attribute is NOT env-aws, display this content. For more information, see https://docs.asciidoctor.org/asciidoc/latest/directives/ifdef-ifndef/.

Before you begin with the CircleCI server v4.x core services installation phase, ensure all <<phase-1-prerequisites#,prerequisites>> are met.

.Installation Experience Flow Chart Phase 2
image::server-install-flow-chart-phase2.png[Flow chart showing the installation flow for server 3.x with phase 2 highlighted]

NOTE: In the following sections replace any items or credentials displayed between `< >` with your details.

toc::[]

CircleCI server is installed as a helm chart.

[#step-one-create-a-namespace]
== Step one: Create a namespace
Create a namespace to install the application into.

[source,shell]
----
kubectl create ns circleci-server
----

TIP: Once you have created your namespace, we recommend setting your `kubectl` context too, with the following command: `kubectl config set-context --current --namespace <namespace>`

[#step-two-pull-image-from-dockerhub]
== Step two: Pull image from DockerHub

CircleCI's images are stored in a dockerhub repository. Credentials to pull the images from CircleCI's dockerhub will be provided to you as part of the onboarding process. A `docker-registry` Kubernetes secret will be used to pull images from a docker repository.

* **Option 1: Your application has access to the public internet**
+
The username and password will be provided to you.  This example pulls the images from CircleCI's repository directly.
+
[source,shell]
----
kubectl create secret docker-registry regcred \
  --docker-server=https://index.docker.io/v2/ \
  --docker-username=<your-username> \
  --docker-password=<your-access-token> \
  --docker-email=<your-email>
----

* **Option 2: Your application does NOT have access to the public internet**
+
Pull and store the images in whatever docker repository you have available.  Credentials to pull the images from CircleCI's dockerhub will be provided to you.  The `docker-registry` kubernetes secret you will use will take the following form.
+
[source,shell]
----
kubectl create secret docker-registry regcred \
  --docker-server=<your-docker-image-repo> \
  --docker-username=<your-username> \
  --docker-password=<your-access-token> \
  --docker-email=<your-email>
----

[#step-three-create-helm-values]
== Step three: Create helm values

Before installing CircleCI, it is recommended to create a new `values.yaml` file unique to your installation. The following describes the minimum required values to include in `values.yaml`. Additional customizations are available, see the provided `values.yaml` for all available options.

For sensitive data there are two options: 

* add into the values.yaml file 
* add them as Kubernetes secrets directly

This flexibility allows you to manage secrets using whichever process you prefer. 

NOTE: Whichever option you choose, this sensitive information is stored as a kubernetes secret within CircleCI.

[#api-token]
=== API token

The application requires a secret containing an API token. This API token is used to facilitate internal API communication to api-service. Use a random string and store it securely, CircleCI will not be able to recover this value if lost. There are two options:

* *Option 1 - Create the secret yourself*
+
[source,shell]
----
kubectl create secret generic api-token \
  --from-literal=api-token=<super-secret-random-value>
----

* *Option 2 - CircleCI creates the secret*
+
Add the value to `values.yaml`. CircleCI will create the secret automatically.
+
[source,yaml]
----
apiToken: <super-secret-random-value>
----

[#session-cookie]
=== Session cookie

The application requires a session cookie key secret, which CircleCI uses to sign session cookies. The key secret must be exactly 16 characters long. Use a random string and store it securely, CircleCI will not be able to recover this value if lost. There are 2 options:

* *Option 1 - Create the Secret yourself*
+
[source,shell]
----
kubectl create secret generic session-cookie \
--from-literal=session-cookie-key=<secret-key-16-chars>
----

* *Option 2 - CircleCI creates the secret*
+
Add the value to values.yaml.  CircleCI will create the secret automatically. 
+
[source,yaml]
----
sessionCookieKey: <secret-key-16-chars>
----

[#encryption]
=== Encryption

The application requires a secret containing signing and encrpytion keysets. These keysets are used to encrypt and sign artifacts generated by CircleCI. These keys were created during the prerequisites phase. CircleCI will not be able to recover the values if lost. Depending on how you prefer to manage secrets, there are 2 options.

* *Option 1 - Create the secret yourself*
+
[source,shell]
----
kubectl create secret generic signing-keys \
  --from-literal=signing-key=<your-generated-signing-key> \
  --from-literal=encryption-key=<your-generated-encryption-key> 
----

* *Option 2 - CircleCI creates the secret*
+
Add the value to values.yaml.  CircleCI will create the secret automatically. 
+
[source,yaml]
----
keyset:
  signing: <your-generated-signing-key>
  encryption: <your-generated-encryption-key>
----

#TODO: Put the rest of the secret instructions here#

https://circleci.atlassian.net/browse/SERVER-1823

https://circleci.atlassian.net/browse/SERVER-1819

https://circleci.atlassian.net/browse/SERVER-1821

https://circleci.atlassian.net/browse/SERVER-1820

https://circleci.atlassian.net/browse/SERVER-1822

[#global]
=== Global
All values in this section are children of global.

[#circleci-domain-name]
==== CircleCI domain name (required)
Enter the domain name you specified when creating your Frontend TLS key and certificate.

[source,yaml]
----
  domainName: <domain-name-for-circleci>
----

[#tls]
=== TLS
For TLS, you have 4 options: 

* Do nothing.  https://letsencrypt.org/[Let's Encrypt] will automatically request and manage certificates for you.  This is a good option for trials, it is not recommended for production use.

* You can supply a private key and certificate
+
You may have created this during the prerequisite steps. You can retrieve the values with the following commands:
+
[source,bash]
----
cat /etc/letsencrypt/live/<CIRCLECI_SERVER_DOMAIN>/privkey.pem
cat /etc/letsencrypt/live/<CIRCLECI_SERVER_DOMAIN>/fullchain.pem
----
+
Add them to `values.yaml``:
+
[source,yaml]
----
tls:
  certificate: "<full-chain>"
  privateKey: "<private-key>"
----

* Have https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html[AWS Certificate Manager (ACM)] automatically request and manage certificates for you.  Follow the https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html[ACM documentation] for instructions on how to generate ACM certificates.
+
Enable `aws_acm` and add the `service.beta.kubernetes.io/aws-load-balancer-ssl-cert` annotation to point at the ACM ARN
+
[source,yaml]
----
nginx:
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: <acm-arn>
  aws_acm:
    enabled: false
----
+
[WARNING]
==== 
If you have already deployed CircleCI server, enabling ACM is a destructive change to the loadbalancer. The service will have to be regenerated to allow the use of your ACM certificates and so the associated loadbalancer will also be regenerated. 
You will need to update your DNS records to the new loadbalancer once you have redeployed CircleCI server.
====

* Disable TLS termination within CircleCI.  The system will still need to be accessed over HTTPS, so TLS termination will be required somewhere upstream of CircleCI.  Implement this by following step 1 (do nothing) and forward to CircleCI on port 80 after terminating TLS.

[#step-four-github-integration]
== Step four: GitHub integration
To configure GitHub with CircleCI, there are two options for providing credentials to the deployment. Steps for both GitHub and GitHub Enterprise (GHE) are given in the next two sections.

[#github]
=== GitHub
These instructions are for the non-enterprise version of GitHub.  Use the client ID and secret you created with your Github OAuth application in the prerequisite phase.

* *Option 1 - Create the secret yourself*
+
[source,shell]
----
kubectl create secret generic github-secret \
  --from-literal=clientId=<client-id> \
  --from-literal=clientSecret=<client-secret> 
----

* *Option 2 - CircleCI creates the secret*
+
Add the client ID and secret to 
the `values.yaml` file. CircleCI will create the secret automatically.
+
[source,yaml]
----
github:
  clientId: <client-id>
  clientSecret: <client-secret>
----


[#github-enterprise]
=== GitHub Enterprise

The instructions for GitHub Enterprise are similar, with a few extra steps to enable enterprise and create the required default token.

In GHE, Create the `defaultToken` by navigating to **Settings > Developer Settings > Personal access tokens**. The default token requires no scopes.  You will also need the client ID and secret you created with your Github OAuth application in the prerequisite phase.

After creating the default token, there are two setup options:

* *Option 1 - Create the secret yourself*
+
[source,shell]
----
kubectl create secret generic github-secret \
  --from-literal=clientId=<client-id> \
  --from-literal=clientSecret=<client-secret> \
  --from-literal=defaultToken=<default-token>
----
+
You must then provide the following to the values.yaml file:
+
[source,yaml]
----
github:
  enterprise: true
  hostname: <github-enterprise-hostname>
----

* *Option 2 - CircleCI creates the secret*
+
Add `clientID`, `clientSecret` and `defaultToken` to 
the `values.yaml` file. You must also set `enterprise` to `true`, and provide the `hostname` for your enterprise GitHub. CircleCI will create the secret automatically.
+
[source,yaml]
----
github:
  clientId: <client-id>
  clientSecret: <client-secret>
  enterprise: true
  hostname: <github-enterprise-hostname>
  defaultToken: <token>
----


[#object-storage]
== Step five: Object storage

Regardless of your storage provider, a bucket name will need to be included. Your created this during the prerequisites phase.

[source,yaml]
----
object_storage:
  bucketName: <bucket-name>
----

// Don't include this section in the GCP PDF.
ifndef::env-gcp[]

[#s3-compatible]
=== S3 compatible
Add an `s3` section as a child of `object_storage`.  The `endpoint` in the case of AWS S3 is the https://docs.aws.amazon.com/general/latest/gr/rande.html[regional endpoint].  Otherwise it is the API endpoint fo your object storage server

[source,yaml]
----
  s3:
    enabled: true
    endpoint: <storage-server-or-s3-endpoint>
----

Under `object_storage.s3`, add either the `accessKey` and `secretKey` or `irsaRole`.  They were created during the prerequisite steps.

* *Option 1 - IAM access keys*
+
Add the following to the `object_storage.s3` section:
+
[source,yaml]
----
    accessKey: <access-key>
    secretKey: <secret-key>
----

* *Option 2 - IRSA*
+
Add the following to the `object_storage.s3` section:
+
[source,yaml]
----
    region: <role-region>
    irsaRole: <irsa-arn>
----

// Stop hiding from GCP PDF:
endif::env-gcp[]

// Don't include this section in the AWS PDF:
ifndef::env-aws[]

[#google-cloud-storage]
=== Google Cloud Storage

Under `object_storage` add the following.

[source,yaml]
----
gcs:
    enabled: true
----

Under `object_storage.gcs` add either `service_account` or `workloadIdentity`. They were created during the prerequisite steps.

* *Option 1 - Service Account*
+
Add a JSON format key of the Service Account to use for bucket access.  Add the following to the `object_storage.gcs` section:
+
[source,yaml]
----
service_account: <service-account>
----

* *Option 2 - Google Workload Identity*
+
Add the Service Account Email of the workload identity.  Add the following to the `object_storage.gcs` section:
+
```
workloadIdentity: <workload-identity-service-account-email>
```

// Stop hiding from AWS PDF
endif::env-aws[]

[#step-six-save-and-deploy]
== Step six: Save and deploy
Once you have completed the fields detailed above, you can deploy. The deployment installs the core services and provides you with an IP address for the Kong load balancer. That IP address is critical in setting up a DNS record and completing the first phase of the installation.

. Pull all the helm dependencies:
+
[source,shell]
----
helm dep update
----

. Install CircleCI Server:
+
[source,shell]
----
helm install server -f values.yaml <path-to-helm-chart>
----

[#step-seven-create-dns-entry]
== Step seven: Create DNS entry
Create a DNS entry for your nginx load balancer, for example, `circleci.your.domain.com` and `app.circleci.your.domain.com`. The DNS entry should align with the DNS names used when creating your TLS certificate and GitHub OAuth app during the prerequisites steps. All traffic will be routed through this DNS record.

You need the IP address, or, if using AWS, the DNS name of the nginx load balancer. You can find this information with the following command:

[source,shell]
----
kubectl get service circleci-proxy
----

For more information on adding a new DNS record, see the following documentation:

* link:https://cloud.google.com/dns/docs/records#adding_a_record[Managing Records] (GCP)

* link:https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-creating.html[Creating records by using the Amazon Route 53 Console] (AWS)

[#step-eight-validation]
== Step eight: Validation

You should now be able to navigate to your CircleCI server installation and log in to the application successfully.

Now we will move on to build services. It may take a while for all your services to be up. You can periodically check by running the following command (you are looking for the “frontend” pod to show a status of _running_ and **ready** should show 1/1):

[source,shell]
----
kubectl get pods -n <YOUR_CIRCLECI_NAMESPACE>
----

ifndef::pdf[]
[#next-steps]
== Next steps

* <<phase-3-execution-environments#,Phase 3: Execution Environments Installation>>
endif::[]
