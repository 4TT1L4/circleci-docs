= Release Orchestration Concepts
:page-layout: classic-docs
:page-liquid:
:icons: font
:toc: macro

== Applications

Conceptually, an application is a collection of microservices sharing a single Kubernetes namespace.

Release Orchestration also allows you to release across multiple Kubernetes clusters and multiple cloud providers. In this case, an _application_ is a unique combination of a Kubernetes cluster and a Namespace name.

NOTE: The Release Orchestration definition of an application differs from the Kubernetes definition. In Kubernetes, an application is a single workload, plus configuration data.

* See the <<using-release-orchestration/applications.adoc#,Applications doc>> for more information.

== Policies

A _policy_ is a set of rules that defines how a version of a service should be validated when it is added to an application. If the policy conditions are not met, the new version is rolled back, with minimal impact on your users' experience.

In Site Reliability Engineering (SRE) terms, a policy validates that a new version of a service complies with the Service Level Objectives (SLOs) defined for that service.

Release Orchestration supports:

* <<using-release-orchestration/policies#release-policies,Release policies>>
* <<using-release-orchestration/policies#validation-only-policies,Validation-only policies>>

== Releases

There is significant confusion between the terms _deploy_ and _release_. The two terms refer to different acts, one technical and one business-driven.

The key distinction between a _deployment_ and a _release_ is the business purpose.

A deploy or deployment includes all the technical activities needed to make an application or feature available for use. For example, a fresh Docker container running in a Pod on a Kubernetes cluster. The software has passed all checks and tests in your CI/CD pipeline and is ready to receive traffic from production users, but it is not yet receiving any traffic. This part of the process just ensures the new version is healthy and running smoothly; it does not incur any the risk involved in serving production traffic. Based on this definition, _deploying_ software is a risk-free activity.

A release comes _after_ a deployment and includes all the activities needed to move part of, or all, production traffic to the new version. All the business risks and problems (such as downtime, lost revenue, and unhappy customers) are related to the _release_, not to the deployment. _Releasing_ software is riskier than _deploying_ software. You may choose to release a new version as soon as it is deployed into production, but that should be a conscious business decision.

Release Orchestration provides you with the tools to manage that risk. This feature simultaneously protects your users' experience and ensures new microservices versions are truly delivering additional business value.

There are two main types of release: _blue/green_ and _canary_.

=== Blue/Green Release

A blue/green release uses two identical environments called _blue_ and _green_. The current live version is _blue_; the new version is _green_.

A blue/green release policy includes only one step that targets all your users. At the start of the step, all users are switched from the live _blue_ version to the new _green_ version.

The Release Agent monitors the performance of the new version. If everything is released successfully, the policy completes with the _green_ version becoming the live version.

If the new version does not meet all the conditions specified in the release policy, the Release Agent immediate rolls back by switching all users to the _blue_ version.

=== Canary Release

A canary release uses a subset of users to identify any issues before a new version is rolled out to all users.

A canary release policy typically includes three or more steps that  target progressively larger subsets of users. A step can target a percentage of your users, or it can target a specific <<using-release-orchestration/segments#,user segment>>.

The Release Agent monitors the performance of the new version. If everything is released successfully, the policy completes with all users receiving the new version.

If the new version does not meet all the conditions specified in the release policy, the Release Agent immediately rolls back by switching all users to the current, live version.

* See <<using-release-orchestration/policies#,Policies>> for more information on release policies.

== Services

In Release Orchestration, a _service_ represents a single microservice within an application. A version of that service is released, and release orchestration describes the steps that must be taken to establish whether that service _version_ can become live. Many of those steps are specified in a release policy.

A service version can be reused across multiple applications. _Release modelling_ is used to plan the order in which each service version is released into the different applications. For example, some business need to deploy different versions to customers in different regions, across multiple Kubernetes clusters and cloud providers.

As a _service_ can span multiple versions and multiple applications, you can track and compare the performance and reliability of your microservices. You can do this either individually, or as interdependent microservices within an application.

[NOTE]
====
The Release Orchestration definition of a service differs significantly from the definition of a Kubernetes Service.

Kubernetes defines a Service as a network service, an abstract way to expose a set of Pods using a single DNS name and a load balancing strategy.

A service in Release Orchestration represents a superset of Kubernetes artifacts: a Kubernetes workload (a Deployment) plus, optionally, a Kubernetes Service.
====

* See the <<using-release-orchestration/services.adoc#,Services doc>> for more information.