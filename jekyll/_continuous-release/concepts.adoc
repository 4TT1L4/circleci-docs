= Continuous Release Concepts
:page-layout: classic-docs
:page-liquid:
:icons: font
:toc: macro

== Applications

Conceptually, an application is a collection of microservices sharing a single Kubernetes namespace.

Release Orchestration also allows you to release across multiple Kubernetes clusters and multiple cloud providers. In this case, an _application_ is a unique combination of a Kubernetes cluster and a Namespace name.

NOTE: The Release Orchestration definition of an application differs from the Kubernetes definition. In Kubernetes, an application is a single workload, plus configuration data.

== Policies

A _policy_ is a set of rules that defines how a version of a service should be validated when it is added to an application. If the policy conditions are not met, the new version is rolled back, with minimal impact on your users' experience.

In Site Reliability Engineering (SRE) terms, a policy validates that a new version of a service complies with the Service Level Objectives (SLOs) defined for that service.

Release Orchestration supports _release policies_ and _validation-only policies_.

=== Release Policies

A release policy defines a set of validation rules for how Vamp objectively tests if a version of a service meets its objectives. It also defines the user segments to be targeted during the tests.
Release policies are used for services that support progressive releases using traffic shaping. 

Normally as the release progresses, increasing numbers of API requests are sent to the newly deployed version of the service. If it passes all the tests defined in the policy, then it is designated as the live version, replacing the current version.

If validation of the newly deployed version of the service fails for any reason, it is rolled back. The current version remains live and receives all API requests. The failed version no longer receives any API requests.

* See <<using-release-orchestration/policies#,Policies>> for more information on release policies.
* See <<using-release-orchestration/segments#,Segments>> for more information on user segments.

=== Validation-Only Policies

A validation-only policy defines the set validation rules to objectively test whether a version of a service meets its objectives.

Validation-only policies rely on calling a user-defined #webhook# to roll back a failed version. If the newly released version passes all the tests defined in the policy, it remains the live version. 

If validation of the newly deployed version of the service fails for any reason, Release Automation calls a webhook to roll back the service to the previous version. Typically, this webhook triggers an action on a CD pipeline.

* See <<using-release-orchestration/policies#,Policies>> for more information on validation-only policies.
* See <<using-release-orchestration/webhooks#,Webhooks>> for more information on webhooks.

== Releases

There is significant confusion between the terms _deploy_ and _release_. The two terms refer to different acts, one technical and one business-driven.

The key distinction between a _deployment_ and a _release_ is the business purpose.

A deploy or deployment includes all the technical activities needed to make an application or feature available for use. For example, a fresh Docker container running in a Pod on a Kubernetes cluster. The software has passed all checks and tests in your CI/CD pipeline and is ready to receive traffic from production users, but it is not yet receiving any traffic. This part of the process just ensures the new version is healthy and running smoothly; it does not incur any the risk involved in serving production traffic. Based on this definition, _deploying_ software is a risk-free activity.

A release comes _after_ a deployment and includes all the activities needed to move part of, or all, production traffic to the new version. All the business risks and problems (such as downtime, lost revenue, and unhappy customers) are related to the _release_, not to the deployment. _Releasing_ software is riskier than _deploying_ software. You may choose to release a new version as soon as it is deployed into production, but that should be a conscious business decision.

// signpost release policies and Release Agent here.

Release Orchestration provides you with the tools to manage that risk. This feature simultaneously protects your users' experience and ensures new microservices versions are truly delivering additional business value.

== Services

In Release Orchestration, a _service_ represents a single microservice within an application. A version of that service is released, and release orchestration describes the steps that must be taken to establish whether that service _version_ can become live. Many of those steps are specified in a #release policy#.

A service version can be reused across multiple applications. _Release modelling_ is used to plan the order in which each service version is released into the different applications. For example, some business need to deploy different versions to customers in different regions, across multiple Kubernetes clusters and cloud providers.

As a _service_ can span multiple versions and multiple applications, you can track and compare the performance and reliability of your microservices. You can do this either individually, or as interdependent microservices within an application.

[NOTE]
====
The Release Orchestration definition of a service differs significantly from the definition of a Kubernetes Service.

Kubernetes defines a Service as a network service, an abstract way to expose a set of Pods using a single DNS name and a load balancing strategy.

A service in Release Orchestration represents a superset of Kubernetes artifacts: a Kubernetes workload (a Deployment) plus, optionally, a Kubernetes Service.
====